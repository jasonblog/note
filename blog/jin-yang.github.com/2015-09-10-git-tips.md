---
title: Git 使用杂项
layout: post
comments: true
language: chinese
category: [linux,misc]
keywords: git,示例
description: 记录 git 常见的示例，可以用来作为参考使用。
---

记录 git 常见的示例，可以用来作为参考使用。

<!-- more -->

<!--
顺手把别的项目翻出来看，也有很实用的工具，比如git-review。

git-review为git新增了一个很方便的代码review途径，利用这个命令，可以调用别的工具比如vimdiff来review代码的改动。下面简单记录一下使用的过程：
下载并安装

首先确认已经装好了git，剩下的事情比较简单。


git clone git://github.com/facebook/git-review.git
cd git-review
python setup.py install

这几步为git新增了一个review命令。
git-review的使用
查看指定版本的改动


git review 58e2fb834793f5c6c1fdd900a1c0224a44735962

出现提示

    Now processing modified file foo.php
    foo.php [diff]>

由于我配置了diff工具为vimdiff，所以接下来就可以用vimdiff查看foo.php在58e2fb834793f5c6c1fdd900a1c0224a44735962这个版本与最新版本之间有什么不同。
查看两个版本之间的改动


git review 5b744bdc5f5bcbcfd6bb65f815aebe6bdce8c427 58e2fb834793f5c6c1fdd900a1c0224a44735962

在review每个代码之前，都可以使用help查看git review命令的帮助，如果放弃review，那么直接敲退出就可以了。

https://github.com/openstack-infra/git-review
https://pypi.python.org/pypi/git-review
-->

## 免登陆

对于不同的 git 版本，可以有如下的几种设置方式。

<!--
http://stackoverflow.com/questions/5343068/is-there-a-way-to-skip-password-typing-when-using-https-on-github/5343146#5343146
-->
### http

#### v1.7.9 later

git-v1.7.9 之后的版本，对于 HTTP(S) 链接方式，可以通过 [Credential Helpers](https://www.kernel.org/pub/software/scm/git/docs/v1.7.9/gitcredentials.html) 实现免登陆，可以通过如下方式配置。

{% highlight text %}
----- 直接缓存在内存中
$ git config --global credential.helper cache

----- 默认过期时间为15min，可以通过如下方式设置为1hour
$ git config --global credential.helper "cache --timeout=3600"
{% endhighlight %}

除了 cache 之外，还可以用各个平台上的 keyring 工具，例如 MacOS (osxkeychain)、Windows (wincred)、Linux (gnome-keyring) 等。

#### v1.7.9 before

对于 v1.7.9 之前版本，可以设置配置文件中的 origin URL，将其配置为如下内容。

{% highlight text %}
https://you:password@github.com/you/example.git
{% endhighlight %}

当然，也可以通过如下命令进行配置。

{% highlight text %}
$ git config remote.origin.url https://you:password@github.com/you/example.git
{% endhighlight %}

不过这种方式的 **密码是明文保存的**，其安全性显而易见。

#### netrc

这个是通用的方式，不过也是明文保存密码。

{% highlight text %}
$ chmod 600 ~/.netrc
$ cat ~/.netrc
machine <hostname> login <username> password <password>
{% endhighlight %}

对于 Windows 则文件要命名为 ```_netrc```，同时设置好 ```%HOME%``` 环境变量。

### ssh

首先设置全局配置。

{% highlight text %}
$ git config --global user.name "foobar hello"
$ git config --global user.email "foobar@kidding.com"
{% endhighlight %}

#### SSH模式免登陆配置

注意: **一定要保护好私钥文件**。

{% highlight text %}
$ ssh-keygen -t rsa -N "" -f ~/.ssh/git_id -C "jinyang3@huawei.com"
$ cat << EOF >> ~/.ssh/config
# 添加的是git@之后的域名
Host gitlab.com
    User foobar
    Identityfile ~/.ssh/git_id
EOF
{% endhighlight %}

然后在 gitlab 的个人 Profile 中，也就是 ```Profile Setting=>SSH Kyes```，添加上述生成的公钥，通过如下方式测试。

{% highlight text %}
$ ssh -T git@gitlab.com
Welcome to GitLab, foobar hello!
{% endhighlight %}

## 修改已提交 commit

经常会遇到一些不希望的提交，例如误添加了密码，所以就会有增删改某次或某些提交的需求，这里简单收集下修改本地和远程版本历史的一些方法。


<!--
https://github.com/uolcano/blog/issues/12
### 本地修改
    修改最近一次的commit

    修改提交的描述

    git commit --amend

    然后会进入一个文本编辑器界面，修改commit的描述内容，即可完成操作。

    修改提交的文件

    git add <filename> # 或者 git rm
    git commit --amend # 将缓存区的内容做为最近一次提交

    修改任意提交历史位置的commit

    可以通过变基命令，修改最近一次提交以前的某次提交。不过修改的提交到当前提交之间的所有提交的hash值都会改变。
    变基操作需要非常小心，一定要多用git status命令来查看你是否还处于变基操作，可能某次误操作的会对后面的提交历史造成很大影响。

    首先查看提交日志，以便变基后，确认提交历史的修改

    git log

    变基操作。 可以用commit~n或commit^^这种形式替代：前者表示当前提交到n次以前的提交，后者^符号越多表示的范围越大，commit可以是HEAD或者某次提交的hash值；-i参数表示进入交互模式。

    git rebase -i <commit range>

    以上变基命令会进入文本编辑器，其中每一行就是某次提交，把pick修改为edit，保存退出该文本编辑器。

    **注意：**变基命令打开的文本编辑器中的commit顺序跟git log查看的顺序是相反的，也就是最近的提交在下面，老旧的提交在上面

    **注意：**变基命令其实可以同时对多个提交进行修改，只需要修改将对应行前的pick都修改为edit，保存退出后会根据你修改的数目多次打开修改某次commit的文本编辑器界面。但是这个范围内的最终祖先commit不能修改，也就是如果有5行commit信息，你只能修改下面4行的，这不仅限于commit修改，重排、删除以及合并都如此。

    git commit --amend

    接下来修改提交描述内容或者文件内容，跟最近一次的commit的操作相同，不赘述。

    然后完成变基操作

    git rebase --continue

    有时候会完成变基失败，需要git add --all才能解决，一般git会给出提示。

    再次查看提交日志，对比变基前后的修改，可以看到的内的所有提交的hash值都被修改了

    git log

    如果过了一段时间后，你发现这次历史修改有误，想退回去怎么办？请往下继续阅读

    重排或删除某些提交

    变基命令非常强大，还可以将提交历史重新手动排序或者删除某次提交。这为某些误操作，导致不希望公开信息的提交，提供了补救措施

    git rebase -i <commit range>

    如前面描述，这会进入文本编辑器，对某行提交进行排序或者删除，保存退出。可以是多行修改。

    后续操作同上。

    合并多次提交

    非关键性的提交太多会让版本历史很难看、冗余，所以合并多次提交也是挺有必要的。同样是使用以上的变基命令，不同的是变基命令打开的文本编辑器里的内容的修改。

    将pick修改为squash，可以是多行修改，然后保存退出。这个操作会将标记为squash的所有提交，都合并到最近的一个祖先提交上。

    **注意：**不能对的第一行commit进行修改，至少保证第一行是接受合并的祖先提交。

    后续操作同上。

    分离某次提交

    变基命令还能分离提交，这里不描述，详情查看后面的参考链接

    终极手段

    git还提供了修改版本历史的“大杀器”——filter-branch，可以对整个版本历史中的每次提交进行修改，可用于删除误操作提交的密码等敏感信息。

    删除所有提交中的某个文件

    git filter-branch --treefilter 'rm -f password.txt' HEAD

    将新建的主目录作为所有提交的根目录

    git filter-branch --subdirectory-filter trunk HEAD

本地回退

回退操作也是对过往提交的一剂“后悔药”，常用的回退方式有三种：checkout、reset和revert

    checkout

    对单个文件进行回退。不会修改当前的HEAD指针的位置，也就是提交并未回退

    可以是某次提交的hash值，或者HEAD（缺省即默认）

    git checkout <commit> -- <filename>

    reset

    回退到某次提交。回退到的指定提交以后的提交都会从提交日志上消失
    **注意：**工作区和暂存区的内容都会被重置到指定提交的时候，如果不加--hard则只移动HEAD的指针，不影响工作区和暂存区的内容。

    git reset --hard <commit>

    结合git reflog找回提交日志上看不到的版本历史，撤回某次操作前的状态

    git reflog # 找到某次操作前的提交hash值
    git reset <commit>

    这个方法可以对你的回退操作进行回退，因为这时候git log命令已经找不到历史提交的hash值了。

    revert

    这个方法是最温和，最受推荐的，因为本质上不是修改过去的版本历史，而是将回退版本历史作为一次新的提交，所以不会改变版本历史，在push到远程仓库的时候也不会影响到团队其他人。

    git revert <commit>

远程修改

对远程仓库的版本历史修改，都是在本地修改的基础上进行的：本地修改完成后，再push到远程仓库。

但是除了git revert可以直接push，其他都会对原有的版本历史修改，只能使用强制push

git push -f <remote> <branch>

总结

git commit --amend改写单次commit
git rebase -i <commit range>删改排以及合并多个commit
git checkout <commit> -- <filename>获取历史版本的某个文件
git reset [--hard] <commit>移动HEAD指针
git revert <commit>创建一个回退提交
git push -f <remote> <branch>强制push，覆盖原有远程仓库
-->


## 常用命令

{% highlight text %}
----- 配置用户名密码
$ git config --global user.name  "Your Name"
$ git config --global user.email "yourname@example.com"
$ git config --list

----- 如果不关心文件权限等，如Windows中
$ git config core.filemode false

----- 初始化或者clone一个库
$ git init
$ git clone https://github.com/user/repository.git
$ git help clone

----- 从远端更新，origin指定远端库，master为远端分支
$ git pull origin master              ← 等价于fetch+merge
$ git fetch origin master             ← 只获取远程分支
$ git merge origin master             ← 手动合并

----- 查看远端服务器，修改origin，以及添加remote分支
$ git remote -v
$ git remote set-url origin http//github.com/repo.git
$ git remote add remote-name https://github.com/user/repo.git

----- 查看提交的差异内容
$ git diff                                               ← 未添加到staged的提交
$ git diff --cached                                      ← 已经staged但是未commited的提交
$ git diff origin/master                                 ← 本地修改与远端master的差异
$ git diff COMMIT1_ID COMMIT2_ID                         ← 两次提交的修改
$ git diff --name-only COMMIT1_ID COMMIT2_ID             ← 只查看修改的文件
$ git diff-tree --no-commit-id --name-only -r COMMIT_ID  ← 某次提交的修改
$ git show --pretty="format:" --name-only COMMIT_ID      ← 同上
$ git show COMMIT_ID                                     ← 查看详细细节

----- 当前的状态，然后添加到staged，并提交
$ git status
$ git add changed_file.txt
$ git add folder-with-changed-files/
$ git commit -m "Commiting changes"

----- 重命名或者删除一些文件
$ git rm removeme.txt tmp/crap.txt
$ git mv file_oldname.txt file_newname.txt
$ git commit -m "deleting 2 files, renaming 1"

----- 修改最近一次提交的提交信息，并提交到远端
$ git commit --amend -m "New commit message"
$ git push origin master

----- 查看日志
$ git log                                                ← 最近的提交日志
$ git log -2                                             ← 最近的两个提交日志
$ git log -p -2                                          ← 查看最近两次的详细日志
$ git log --pretty=oneline                               ← 单行打印

----- 通过一次提交回退一次提交，会保存一次新的commit
$ git revert dd61ab21
----- 取消一次提交
$ git reset --soft  HEAD~1                               ← 删除上次commit，文件回退到stage
$ git reset --soft  HEAD@{1}
$ git reset --mixed HEAD~1                               ← (默认)删除上次commit，文件回退到工作区
$ git reset --hard  HEAD~1                               ← 彻底回到上次commit，文件回被删除
$ git reset 56e05fced
$ git reset origin/master                                ← 取消本地未提交的内容
$ git fetch origin                                       ← 或者直接获取远端的内容
$ git reset --hard origin/master                         ← 接上

----- 插件本地分支以及所有分支
$ git branch
$ git branch -a

----- 生成patch文件
$ git diff > patch-issue-1.patch                         ← 做些修改，创建patch
$ git add newfile                                        ← 新建文件并创建patch
$ git diff --staged > patch-issue-2.patch                ← 接上
$ git add newfile                                        ← 添加新文件，做些修改并创建一个patch
$ git diff HEAD > patch-issue-2.patch                    ← 接上
$ git format-patch COMMIT_ID                             ← 为某个commit生成patch
$ git format-patch HEAD~2                                ← 最近两次提交生成patch
$ git format-patch origin/master                         ← 为所有未提交内容生成patch
$ git format-patch --binary --full-index origin/master   ← 创建包含二进制文件的patch
$ git apply -v patch-name.patch                          ← 应用patch
$ git am patch1.patch                                    ← 应用通过format-patch生成的patch
{% endhighlight %}




<!--
Create a tag

git tag 7.x-1.3

Push a tag

git push origin 7.x-1.3

Create a branch

git checkout master
git branch new-branch-name

Here master is the starting point for the new branch. Note that with these 2 commands we don't move to the new branch, as we are still in master and we would need to run git checkout new-branch-name. The same can be achieved using one single command: git checkout -b new-branch-name
Create a branch from a previous commit

git branch branchname 

or using a symbolic reference (e.g. last commit):

git branch branchname HEAD~1

You can also use

git checkout -b branchname 

Source: http://stackoverflow.com/a/2816728/1391963
Checkout a branch

git checkout new-branch-name

See commit history for just the current branch

git cherry -v master

(master is the branch you want to compare)
Merge branch commits

git checkout master
git merge branch-name

Here we are merging all commits of branch-name to master.
Merge a branch without committing

git merge branch-name --no-commit --no-ff

See differences between the current state and a branch

git diff branch-name

See differences in a file, between the current state and a branch

git diff branch-name path/to/file

Delete a branch

git branch -d new-branch-name

Push the new branch

git push origin new-branch-name

Get all branches

git fetch origin

Get the git root directory

git rev-parse --show-toplevel

Source: http://stackoverflow.com/q/957928/1391963
Remove from repository all locally deleted files

git rm $(git ls-files --deleted)

Source: http://stackoverflow.com/a/5147119/1391963
Delete all untracked files

git clean -f

Including directories:

git clean -f -d

Preventing sudden cardiac arrest:

git clean -n -f -d

Source: http://stackoverflow.com/q/61212/1391963
Show total file size difference between two commits

Short answer: Git does not do that.
Long answer: See http://stackoverflow.com/a/10847242/1391963
Unstage (undo add) files:

git reset HEAD file.txt

See closest tag

git describe --tags `git rev-list --tags --max-count=1`

Source. See also git-describe.
Have git pull running every X seconds, with GNU Screen

screen
for((i=1;i<=10000;i+=1)); do sleep 30 && git pull; done

Use Ctrl+a Ctrl+d to detach the screen.
See previous git commands executed

history | grep git

or

grep '^git'  /root/.bash_history

See recently used branches (i.e. branches ordered by most recent commit)

git for-each-ref --sort=-committerdate refs/heads/ | head

Source: http://stackoverflow.com/q/5188320/1391963
Tar project files, excluding .git directory

cd ..
tar cJf project.tar.xz project/ --exclude-vcs

Tar all locally modified files

git diff --name-only | xargs tar -cf project.tar -T -

Look for conflicts in your current files

grep -H -r "<<<" *
grep -H -r ">>>" *
grep -H -r '^=======$' *

There's also git-grep.
Apply a patch not using git:

patch < file.patch
-->


## 常见错误

记录日常遇到的错误异常。

### Certificate Issuer

完整的报错是 `Peer's Certificate issuer is not recognized.` ，主要是由于 HTTPS 的证书无法识别导致，可以将无法识别的证书添加到根证书，或者直接忽略。

这里简单使用后者。

<!--
cd /etc/ssl/certs/
make SERIAL=5
-->

{% highlight text %}
----- 可以通过环境变量设置忽略SSL校验
$ echo 'export GIT_SSL_NO_VERIFY=true' >> ~/.bashrc
$ source ~/.bashrc

----- 也可以在git中进行配置
$ git config http.sslVerify "false"
$ git config --global http.sslVerify false
$ git config http.sslCAinfo /your/path/to/cacert-client.pem
{% endhighlight %}

## 参考

[git - 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)，一些常见的使用命令。

[Git 工具 - 重写历史](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2) 很不错的介绍如何重写历史的工具。



<!--
Git 版本控制系統(3) 還沒 push 前可以做的事
https://ihower.tw/blog/archives/2622
-->

{% highlight text %}
{% endhighlight %}
