# design_patterns

大话设计模式>> c++ 实现, 某些实现非常简单的模式或是开发过程中用的少已经忽略

## Simple Factory Method, 简单工厂 (Creational 创建型)

简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）

创建型：它接受指令，创建出符合要求的实例

计算器选择工厂模式的原因：　计算方法总是不变的

## Strategy, 策略模式 (Behavioral 行为型)

定义一系列的算法把它们一个个封装起来，并且使他们可相互替换．本模式使得算法的变化可独立于使用它的客户．

行为型：它接受已经创建好的实例，实现不同的行为

商场收费软件选择策略模式的原因：　商场收费方式经常发生改变

## Decorator, 装饰模式　（Structural 结构型)

动态的给一个对象添加一些额外的职责．

## proxy 代理模式（Structural 结构型)

real 和　proxy 类均继承同样的接口类，　proxy 里面存储　real　对象的指针，proxy　函数调用 real　的同名函数．

## Factory Method, 工厂模式 (Creational 创建型)

与简单工厂模式的区别就是，每个不同的操作都有自己的工厂，然后由客户端去决定去使用哪个子类工厂．

## Facade 外观模式（Structural 结构型)

对一堆子类进行高层封装，使高层封装提供一致性界面．

## Builder 建造者模式 (Creational 创建型)

当创建复杂对象的算法（流程）应该独立于具体的对象组成部分以及它们的装配方式时使用该模式．创建对象的流程需要稳定，所有具体对象都遵循该流程．

## Observer 观察者模式　(Behavioral 行为型)

类间相互耦合时，一个类的状态发生变化需要通知其他类进行相应更新操作．

## Abstract Factory 抽象工厂模式 (Creational 创建型)

创建一系列相关或相互以来对象的接口，而无需指定它们具体的类．

## State 状态模式　(Behavioral 行为型)

允许一个对象在其内部状态改变时改变它的行为．对象看起来似乎修改了它的类．

## Memento 备忘录　(Behavioral 行为型)

在不破坏封装的前提下，捕获一个对象的内部状态，保存状态，用以恢复原来的状态，对象大时非常消耗内存．

## Singleton 单例模式

懒汉模式，　饿汉模式，　改进双重锁懒汉模式

## Command 命令模式

实现请求与执行的解耦和

## Chain of Responsibility 职责链模式
